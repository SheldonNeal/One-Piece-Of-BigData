# 运行时数据区
## 程序计数器 Program Counter Register  
+ 一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器  
+ 每个线程有自己独立的程序计数器，是线程私有的内存  
+ 如果线程执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果
正在执行的是Native方法，这个计数器值则为空（Umdefined）  
+ 此区域是唯一一个Java虚拟机规范中没有规定任何OutOfMemoryError的区域（因为我们不需要操作这块区域）  
  
## Java虚拟机栈  
+ 虚拟机栈描述的是Java方法执行的动态内存模型（方法栈帧的入栈出栈行为）  
+ **栈帧**
  + 每个方法执行的时候都会创建一个栈帧，伴随方法从创建到执行完成；
  + 保存局部变量表、操作数栈、动态链接、方法出口等信息  
+ **局部变量表**
  + 存放编译期可知的各种基本数据类型、对象引用（reference类型，它不等同于对象本身，可能是
    一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关联的位置）、retunrAddress类型：指向了一条字节码指令的地址  
  + 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量
  空间是完全确定的，在方法运行期间不会改变局部变量表的大小。  
## 本地方法栈 
+ 与虚拟机栈的作用非常类似，只不过虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈为虚拟机执行Native方法服务
## Java堆
+ 线程共享的
+ 存放对象实例的内存区域
+ 垃圾收集器管理的主要区域
## 方法区 
+ 线程共享
+ 存放被虚拟机加载的类信息、常量、静态常量、即时编译器编译后的代码等数据
+ **方法区和永久代**
  + HotSpot虚拟机的设计团队把GC分代手机扩展至方法区，或者说使用永久代来实现方法区，这样HotSpot的垃圾收集器就可以像管理Java堆一样管理这部分内存，
  能够省去专门为方法区编写内存管理代码的工作
  + 垃圾收集行为在这个区域比较少出现
## 运行时常量池
+ 方法区的一部分
+ Class文件中除了有类的版本、字段、方法、接口等信息，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，
这部分内容将在类加载后进入方法区的运行时常量池中存放
+ 运行时常量池相对于Class文件常量池的一个重要特征：具备动态性
  + Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间
  也可能将新的常量放入池中，例如：String类的intern()方法
++ 也会抛出OutOfMemoryError异常
## 直接内存

